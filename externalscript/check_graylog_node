#!/bin/bash
# set -x

# Debug override -- uncomment to write to $LOG, silent otherwise.
DEBUG=1

## Defaults ##
CREDS_FILE=$(dirname $BASH_SOURCE)/check_graylog_node_creds.txt
source $CREDS_FILE
LOG=/tmp/$(basename $0).log
# Default graylog API port
APIPORT=12900
# if several checks are made against a single API endpoint, then use the file for this amount of seconds since the last write.
JSON_FRESHNESS=30
LOCK_FRESHNESS=5
## End defaults  ##

usage() {
    cat <<EOF
Usage: $0 -H <HOSTNAME> -a <ATTRIBUTE> [-p <GRAYLOG_API_PORT>] [-h] [-d]

Args:
    -H : Hostname or IP address of graylog server
    -a : Attribute to monitor. See list below.
    -p : Graylog API port (default: 12900)
    -d : Debug message to log file (default: false)
    -h : Displays help

List of attributes:
    - node_id : returns graylog node_id
    - node_transport
    - node_is_master
    - node_cluster
    - node_type
    - node_throughput
    - lb_status
    - total_message_count : return the node's message count
    - es_cluster_health : return elasticsearch's cluster health
    - journal_size
    - journal_num_segments
    - journal_uncommitted_entries
    - journal_events_read
    - journal_events_append
    - buffer_input_utilization
    - buffer_output_utilization
    - buffer_input_utilization_percent
    - buffer_output_utilization_percent

EOF
}

while getopts hH:a:p::l:d opts; do
    case $opts in
        H)  HOSTNAME=$OPTARG
            ;;
        a)  ATTR=$OPTARG
            ;;
        p)  APIPORT=$OPTARG
            ;;
        h)  usage; exit 0
            ;;
        d)  DEBUG=1
            ;;
        :)  echo "Option -$OPTARG requires an argument."
            exit 1
            ;;
        *)  echo "Invalid option -${OPTARG}."
            exit 1
            ;;
    esac
done

# exit if less than 2 attributes are passed in
[[ $OPTIND -lt 4 ]] && usage && exit 1

CURL_BASE_CMD="curl -u ${USERNAME}:${PASSWORD} -s http://${HOSTNAME}:${APIPORT}"

get_json_info() {
    # $1 = URI -- $2 filename
    debug "[$FUNCNAME] [$(basename $2)] Pulling json data"
    starttime=`date +%s%3N`
    ${CURL_BASE_CMD}${1} | jq '.' > $2
    endtime=`date +%s%3N`
    let runtime=${endtime}-${starttime}
    debug "[$FUNCNAME] [$(basename $2)] --> $runtime ms"
}

# Node related information -- /system/cluster/node
NODE_INFO_FILE=/tmp/${HOSTNAME}-node.json
get_node_info() {
    # Function is called prior to the other related functions below and is only there to write to file.
    # The other functions will read the data from the file to avoid to many API calls.
    debug "[$FUNCNAME] [$(basename $NODE_INFO_FILE)] Getting node info"
    get_json_info "/system/cluster/node" $NODE_INFO_FILE
}
get_node_id() { debug "[$FUNCNAME] Executing" ;jq -r '.node_id' $NODE_INFO_FILE ; }
get_node_transport_addr() { debug "[$FUNCNAME] Executing" ; jq -r '.transport_address' $NODE_INFO_FILE ; }
get_node_is_master() { debug "[$FUNCNAME] Executing" ; jq -r '.is_master' $NODE_INFO_FILE ; }
get_node_cluster() { debug "[$FUNCNAME] Executing" ; jq -r '.cluster_id' $NODE_INFO_FILE ; }
get_node_type() { debug "[$FUNCNAME] Executing" ; jq -r '.type' $NODE_INFO_FILE ; }


# Journal related information -- /system/journal
JOURNAL_INFO_FILE=/tmp/${HOSTNAME}-journal.json
get_system_journal_info() { 
    # Function is called prior to the other related functions below and is only there to write to file.
    # The other functions will read the data from the file to avoid to many API calls.
    debug "[$FUNCNAME] [$(basename $JOURNAL_INFO_FILE)] Getting journal info"
    get_json_info "/system/journal" $JOURNAL_INFO_FILE
}
get_system_journal_events_read() { debug "[$FUNCNAME] Executing" ; jq -r '.read_events_per_second' $JOURNAL_INFO_FILE ; }
get_system_journal_events_append() { debug "[$FUNCNAME] Executing" ; jq -r '.append_events_per_second' $JOURNAL_INFO_FILE ; }
get_system_journal_size() { debug "[$FUNCNAME] Executing" ; jq -r '.journal_size' $JOURNAL_INFO_FILE ; }
get_system_journal_num_segments() { debug "[$FUNCNAME] Executing" ; jq -r '.number_of_segments' $JOURNAL_INFO_FILE ; }
get_system_journal_uncommitted_entries() { debug "[$FUNCNAME] Executing" ; jq -r '.uncommitted_journal_entries' $JOURNAL_INFO_FILE ; }


# Buffer related information -- /system/buffers
BUFFER_INFO_FILE=/tmp/${HOSTNAME}-buffer.json
get_system_buffer_info() {
    # Function is called prior to the other related functions below and is only there to write to file.
    # The other functions will read the data from the file to avoid to many API calls.
    debug "[$FUNCNAME] [$(basename $BUFFER_INFO_FILE)] Getting buffer info"
    get_json_info "/system/buffers" $BUFFER_INFO_FILE
}
get_system_buffer_input_utilization() { debug "[$FUNCNAME] Executing" ; jq -r '.buffers.input.utilization' $BUFFER_INFO_FILE ; }
get_system_buffer_input_utilization_percent() { debug "[$FUNCNAME] Executing" ; jq -r '.buffers.input.utilization_percent' $BUFFER_INFO_FILE ; }
get_system_buffer_output_utilization() { debug "[$FUNCNAME] Executing" ; jq -r '.buffers.output.utilization' $BUFFER_INFO_FILE ; }
get_system_buffer_output_utilization_percent() { debug "[$FUNCNAME] Executing" ; jq -r '.buffers.output.utilization_percent' $BUFFER_INFO_FILE ; }


# Various ungrouped checks
get_lb_status() { debug "[$FUNCNAME] Executing" ; ${CURL_BASE_CMD}/system/lbstatus ;  }
get_total_message_count() { debug "[$FUNCNAME] Executing" ; ${CURL_BASE_CMD}/count/total | jq -r .events ; }
get_es_cluster_status() { debug "[$FUNCNAME] Executing" ; ${CURL_BASE_CMD}/system/indexer/cluster/health | jq -r .status ; }
get_node_throughput() { debug "[$FUNCNAME] Executing" ; ${CURL_BASE_CMD}/system/throughput | jq -r .throughput ; }

poll_data() {
    debug "[$FUNCNAME] [$(basename $NODE_INFO_FILE)] Getting node info"; get_node_info &
    debug "[$FUNCNAME] [$(basename $JOURNAL_INFO_FILE)] Getting journal info"; get_system_journal_info &
    debug "[$FUNCNAME] [$(basename $BUFFER_INFO_FILE)] Getting buffer info"; get_system_buffer_info &

    wait

    if [ -s $NODE_INFO_FILE ] && [ -s $JOURNAL_INFO_FILE ] && [ -s $BUFFER_INFO_FILE ]; then
        echo "OK"
    else
        echo "FAIL"
    fi
}

debug() { 
    if [ ! -z $DEBUG ]; then
        # PPID should be the zabbix poller process and $$ the shell process
        echo -e "$(date '+%Y%m%d %H:%M:%S.%3N') {$PPID} [$$] $@" >> $LOG
    fi
}

case $ATTR in
    node_id)                                get_node_id                                           ;;
    node_transport)                         get_node_transport_addr                               ;;
    node_is_master)                         get_node_is_master                                    ;;
    node_cluster)                           get_node_cluster                                      ;;
    node_type)                              get_node_type                                         ;;
    journal_events_read)                    get_system_journal_events_read                        ;;
    journal_events_append)                  get_system_journal_events_append                      ;; 
    journal_size)                           get_system_journal_size                               ;; 
    journal_num_segments)                   get_system_journal_num_segments                       ;; 
    journal_uncommitted_entries)            get_system_journal_uncommitted_entries                ;;
    buffer_input_utilization)               get_system_buffer_input_utilization                   ;;
    buffer_input_utilization_percent)       get_system_buffer_input_utilization_percent           ;;
    buffer_output_utilization)              get_system_buffer_output_utilization                  ;;
    buffer_output_utilization_percent)      get_system_buffer_output_utilization_percent          ;;
    lb_status)                              get_lb_status                                         ;;
    total_message_count)                    get_total_message_count                               ;;
    es_cluster_health)                      get_es_cluster_status                                 ;;
    node_throughput)                        get_node_throughput                                   ;;
    poll_data)                              poll_data                                             ;;
    
    *)  debug "[Attribute error] Unknown attribute to monitor." && echo "Unknown attribute to monitor"                        ;;
esac
